<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <script src="../../js/lib/vue.min.js"></script>
  <script src="../../js/lib/three/build/three.min.js"></script>
  <style>.container{width: 600px; height: 400px}</style>
</head>
<body>
<div id="app">
  <div class="container" ref="container"></div>
</div>
<script>
  new Vue({
    el: '#app',
    data(){
    	return {
		    camera: null,
		    scene: null,
		    renderer: null,
		    mesh: null,
        group: null,
		    uniforms: {
			    resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
			    iTime: { type: 'f', value: 0 },
			    iResolution: { type: 'v2', value: new THREE.Vector3(100, 100, 1) },
			    iMouse: { type: 'v2', value: new THREE.Vector2() }
		    }
      }
    },
    mounted(){
    	this.initThree()
	    this.animate()
    },
    methods: {
    	initThree(){
		    const vertexShader = `
		      varying vec2 vUv;
          void main(){
            vUv = uv;
            vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
            gl_Position = projectionMatrix * mvPosition;
          }
        `
        const fragmentShader = `
        varying vec2 vUv;
        uniform float iTime;
        uniform vec2 iResolution;
        float reline(vec2 p1, vec2 p2, vec2 pos, float w) {
          vec2 a = (p2-p1)/length(p2-p1);
          vec2 b = pos - p1;
          vec2 p = clamp(dot(a, b), 0., length(p2-p1)) * a + p1;
          // clamp(x,a,b)
          // 如果 x 值小于 a，则返回 a；如果 x 值大于 b，返回 b；否则，返回 x
          // dot(A,B)
          // 返回 A 和 B 的点积(dot product)
          return length(p - pos) - w;
        }
        void main() {
          vec2 position = - 10.0 + 20.0 * vUv;
          position.x = position.y;
          vec2 point1 = vec2(9.,9.);
          vec2 point2 = vec2(9.,-9.);
          vec2 point3 = vec2(-9.,-9.);
          vec2 point4 = vec2(-9.,9.);
          // distance( pt1, pt2)
          // 两点间欧几里得距离
          vec3 l1 = vec3 (reline(point1, point2, position, 1.));
          vec3 l2 = vec3 (reline(point2, point3, position, 1.));
          vec3 l3 = vec3 (reline(point3, point4, position, 1.));
          vec3 l4 = vec3 (reline(point4, point1, position, 1.));
          vec3 res_color = vec3 (1.,1.,1.);
          res_color = mix(res_color, l1, l2);
          res_color = mix(res_color, l3, l4);
          gl_FragColor = vec4(res_color, 1.0);
        }`
        const f = `
        varying vec2 vUv;
        uniform float iTime;
        uniform vec2 iResolution;
        void main() {
          // vec2 position = - 10.0 + 20.0 * vUv;
          vec2 st = vUv.xy / iResolution.xy;
          float aspect = iResolution.x / iResolution.y;
          vec3 color = vec3(1.0);
          vec2 bl = step(vec2(.1), st);
          vec2 tr = step(vec2(.1), 1.-st);
          color = vec3(bl.x * bl.y * tr.x * tr.y);
          gl_FragColor = vec4(color,0.5);
        }`
		    const shaderToy = new THREE.ShaderMaterial({
			    vertexShader,
			    fragmentShader,
			    transparent: true,
			    uniforms: this.uniforms,
			    side: THREE.DoubleSide
		    })
    		const container = this.$refs.container
		    this.camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 1, 1000)
		    this.camera.position.z = 100
        this.scene = new THREE.Scene()
		    this.renderer = new THREE.WebGLRenderer({antialias: true})
		    const geometry = new THREE.BoxGeometry(20, 20, 20)
		    // const material = new THREE.MeshNormalMaterial()
		    const mesh = new THREE.Mesh(geometry, shaderToy)
		    this.group = new THREE.Group()
		    this.group.add(mesh)
		    this.scene.add(this.group)
        this.renderer.setSize(container.clientWidth, container.clientHeight)
		    container.appendChild(this.renderer.domElement)
      },
	    animate() {
		    requestAnimationFrame(this.animate)
		    this.group.rotation.x += 0.005
		    this.group.rotation.y += 0.005
        this.uniforms.iTime.value += 0.01
		    this.renderer.render(this.scene, this.camera)
	    }
    }
  })
</script>
</body>
</html>
