<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <script src="../../js/lib/vue.min.js"></script>
  <script src="../../js/lib/three/build/three.min.js"></script>
  <style>.container{width: 600px; height: 400px}</style>
</head>
<body>
<div id="app">
  <div class="container" ref="container"></div>
</div>
<script>
  new Vue({
    el: '#app',
    data(){
    	return {
		    camera: null,
		    scene: null,
		    renderer: null,
		    mesh: null,
        group: null,
		    uniforms: {
			    resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
			    iTime: { type: 'f', value: 0 },
			    iResolution: { type: 'v2', value: new THREE.Vector3(100, 100, 1) },
			    iMouse: { type: 'v2', value: new THREE.Vector2() }
		    }
      }
    },
    mounted(){
    	this.initThree()
	    this.animate()
    },
    methods: {
    	initThree(){
		    const vertexShader = `
		      varying vec2 vUv;
          void main(){
            vUv = uv;
            vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
            gl_Position = projectionMatrix * mvPosition;
          }
        `
        const fragmentShader = `

        varying vec2 vUv;
        uniform float iTime;
        uniform vec2 iResolution;
        void main() {
          vec2 position = - 1.0 + 2.0 * vUv;
          vec2 uv = position.xy / iResolution.xy;
          uv.x *= iResolution.x / iResolution.y;
          float p1 = vec2(0,0);
          float p2 = vec2(0,1);
          float p3 = vec2(1,1);
          float p4 = vec2(1,0);
          vec2 p = (position.xy - 0.5*iResolution.xy)/iResolution.y;
          float l1 = line(p, p1, p2);
          vec3 color = mix(l1,l2,l3);
          gl_FragColor = vec4(color);
        }`
		    const shaderToy = new THREE.ShaderMaterial({
			    vertexShader,
			    fragmentShader,
			    transparent: true,
			    uniforms: this.uniforms,
			    side: THREE.DoubleSide
		    })
    		const container = this.$refs.container
		    this.camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 1, 1000)
		    this.camera.position.z = 24
        this.scene = new THREE.Scene()
		    this.renderer = new THREE.WebGLRenderer({antialias: true})
		    const geometry = new THREE.BoxGeometry(10, 10, 10)
		    // const material = new THREE.MeshNormalMaterial()
		    const mesh = new THREE.Mesh(geometry, shaderToy)
		    this.group = new THREE.Group()
		    this.group.add(mesh)
		    this.scene.add(this.group)
        this.renderer.setSize(container.clientWidth, container.clientHeight)
		    container.appendChild(this.renderer.domElement)
      },
	    animate() {
		    requestAnimationFrame(this.animate)
		    this.group.rotation.x += 0.005
		    this.group.rotation.y += 0.005
        this.uniforms.iTime.value += 0.01
		    this.renderer.render(this.scene, this.camera)
	    }
    }
  })
</script>
</body>
</html>
